**AtomicInteger.class**의 메서드를 탐방하다 발견하게 된 native 키워드 탐방

```jsx
@IntrinsicCandidate
public final native boolean compareAndSetInt(Object o, long offset, int expected, int x);
```

`native` 키워드는 Java에서 네이티브 코드를 사용해 자바 코드로는 직접 수행하기 어려운 작업을 해결하기 위해 사용됨. Java는 기본적으로 **플랫폼 독립성**을 목표로 설계된 언어지만, 외부에 작업 수행을 맡기기도 한다.

# native 키워드의 역할 및 특징

### 운영체제, 하드웨어 종속작업 처리

Java는 플랫폼 독립성을 가진 언어이지만, 운영 체제나 하드웨어에 종속적인 작업을 처리해야할 때 C/C++로 작성된 네이티브 코드를 호출해 운영 체제의 API나 하드웨어를 직접 제어해야 한다.

- 예:
    - 파일 시스템 접근 (`FileInputStream`, `FileOutputStream`)
    - 네트워크 소켓 관리
    - 그래픽 처리를 위한 GUI 라이브러리 (AWT/Swing)
    - 시스템 시간 가져오기 (`System.currentTimeMillis()`)
    - concurrent(동시성) 관련 코드

### **성능 최적화**

Java는 일반적으로 JVM 위에서 동작하므로 C/C++로 작성된 네이티브 코드에 비해 약간의 오버헤드가 존재. 특히, **자바의 네이티브 메서드**는 속도가 중요한 저수준 작업에서 성능을 극대화하기 위해 사용.

- 예:
    - `AtomicInteger`와 같은 **CAS (Compare-And-Swap)** 연산은 C/C++로 구현된 네이티브 코드를 호출하여 고성능을 보장.
    - `arraycopy()`는 배열 복사를 네이티브 코드로 처리하여 높은 속도를 보장.

### **하드웨어 제어**

Java는 추상화된 언어로, 하드웨어를 직접 제어하는 데 적합하지 않다. 하지만 네이티브 코드를 사용하면 Java 프로그램이 특정 하드웨어 장치를 제어하거나 센서 데이터를 읽을 수 있다.

- 예:
    - 임베디드 시스템에서 Java와 네이티브 코드를 조합해 사용.
    - 특정 하드웨어 기능 호출.

### **멀티스레딩 및 동기화**

Java는 스레드 관리와 동기화 관련 기능을 제공하지만, JVM의 성능을 극대화하거나 플랫폼 종속적인 동기화 메커니즘을 사용하기 위해 네이티브 메서드가 필요할 수 있다.

- 예:
    - `Thread.sleep()`와 같은 메서드는 네이티브 코드를 통해 구현되어 운영 체제의 스레드 관리 기능을 호출.
    - `AtomicInteger`의 `compareAndSet()` 같은 원자적 연산은 하드웨어 명령을 활용한 네이티브 코드로 구현.
