### 👉 클래스(Class)

여러분 혹시 붕어빵 좋아하시나요?🐟

겨울이면 길거리에서 맛있는 붕어빵 많이 보이잖아요.

팥 붕어빵, 슈크림 붕어빵, 요즘은 피자 붕어빵까지… 종류가 엄청 다양하죠?

<br>

그런데 이 붕어빵들을 만들려면 가장 먼저 뭐가 필요할까요?

맞아요! 바로 **붕어빵 틀**입니다.

붕어빵 틀은 항상 같은 모양이죠.

속에 들어가는 재료만 다르면 팥붕, 슈붕, 피자붕이 됩니다!

<br>

자바에서 이 붕어빵 틀처럼,

객체(Object)를 만들기 위한 틀, 즉 설계도를 **클래스(Class)**라고 부릅니다.

<br>

예를 들어, 커피라는 클래스가 있다면?

- **속성** : 메뉴, 가격, 온도
- **행동** : 주문하기, 식기

이런 설계만 적어둔 상태가 바로 클래스입니다!

<br>

**🔹 클래스 기본 형태**

```java
class 클래스명 {
	// 클래스의 내용 : 변수, 메서드..
}
```

<br>

**🔸 클래스 작성 예시**

```java
public class Coffee {
    String menu;
    int price;
    int temperature;

    void order() {
        System.out.println(menu + "를 주문했습니다!");
    }

    void coolDown() {
        temperature -= 10;
        System.out.println("커피가 식었습니다. 현재 온도: " + temperature);
    }
}
```
<br>

**💡 클래스는 왜 필요할까요?**

학교에 다니면 대부분 **교복**을 입죠?

- 윗도리, 바지, 치마, 리본, 넥타이 같은 **공통된 구성**
- 학교마다 색깔이나 디자인은 조금씩 다르지만, **틀은 같습니다**

<br>

그런데 한 학년에 학생이 200명 있다고 해서

학생마다 교복을 새롭게 디자인하진 않죠?

<br>

한 번 만든 교복 디자인(설계)을 기준으로,

**학생마다 사이즈나 이름표**만 다르게 해서 똑같은 교복을 입힙니다.

<br>

이걸 자바로 바꿔서 생각해보면,

- **교복의 설계도** → `클래스(Class)`
- **실제로 입고 있는 교복 하나하나** → `객체(Object)`

<br>

코드로 한 번 봐보겠습니다!

```java
public class Uniform {
    String size;
    String studentName;

    void wear() {
        System.out.println(studentName + " 학생이 교복을 입었습니다. 사이즈: " + size);
    }
}
```

이건 교복 설계서입니다!

<br>

이걸 가지고 우리는

- 김민지 학생의 M 사이즈 교복
- 이준호 학생의 L 사이즈 교복

이런 식으로 다양한 객체(교복 실물)를 만들어낼 수 있습니다.

(만드는 방법은 아래 객체 부분에서 다루겠습니다!)

<br>

학생마다 교복을 매번 새로 디자인한다면?

너무 번거롭고, 비효율적이고, 관리도 안 될 겁니다.

<br>

그래서 학교는 교복의 공통된 틀을 먼저 정하고, 그걸 필요할 때마다 학생에게 맞춰서 입히는 것이에요.

<br>

자바도 똑같아요🤓

자주 쓰이는 구조는 클래스 하나로 정의해두고,

필요할 때마다 다양한 값(이름, 사이즈 등)을 넣어서 객체를 만들어내는 겁니다!

<br>
<br>

### 👉 객체(Object)

클래스가 **붕어빵 틀**이라면,

이제 우리가 실제로 먹을 수 있는 건 바로 **붕어빵 한 마리**겠죠?🐟

<br>

겨울에 붕어빵 틀에 반죽을 넣고, 팥을 넣고, 굽고 나면

비로소 우리가 먹을 수 있는 붕어빵이 완성됩니다!

<br>

그렇게 만들어진 각각의 붕어빵이 바로

자바에서 말하는 **객체(Object)**입니다.

<br>

붕어빵에 대해 다시 얘기해보겠습니다.

<br>

당연히 붕어빵 틀만 가지고는 배가 안 부르겠죠?

팥붕, 슈붕 등 원하는 재료를 넣고 구워야 **진짜 붕어빵**이 만들어집니다!

<br>

자바에서는 이처럼 클래스라는 틀에다가 값을 넣고 **실제로 쓸 수 있는 형태로 만든 것**을 객체라고 부릅니다😊

<br>

정리하자면, 객체(Object)란, 클래스를 바탕으로 만들어진 **실제 사용 가능한 실체**입니다.

- 클래스는 설계도
- 객체는 실물

즉, 실제로 동작하고 값을 담을 수 있는 존재입니다!

<br>

**🔹 객체 생성 기본 문법**

```java
클래스명 변수명 = new 클래스명();
```

 `new` 키워드를 사용해 클래스로부터 객체를 만듭니다.

<br>

**🔸 객체 생성 예시**

```java
Coffee americano = new Coffee();
```

이렇게  객체 생성 후, 아래처럼 객체(커피)의 정보를 넣을 수 있습니다!

```java
c1.menu = "아메리카노";
c1.price = 4000;
c1.temperature = 60;
```

이제 메뉴 이름과 가격, 온도까지 갖고 있는 실체(객체)인 americano가 생성되었습니다!

<br>

교복 비유로도 다시 이어서 설명해보겠습니다.

- 교복의 설계도는 **클래스(Class)**
- 그 설계에 따라 **학생 이름과 사이즈**를 입력해서 **실제로 만들어진 교복 한 벌**은 바로 **객체(Object)**입니다!

<br>

👕 ‘김민지 학생의 교복’, ‘이준호 학생의 교복’은

같은 클래스를 기반으로 만들어진 **서로 다른 객체입니다.**

<br>

**💡 객체가 필요한 이유는?**

클래스만 있다고 해서 실제로 프로그램이 돌아가진 않습니다.

설계도만 그려놓고 제품을 만들지 않으면, **실제로 쓸 수 없겠죠?**

<br>

그래서 자바에서는 클래스를 정의해두고, 그걸 바탕으로 **필요한 만큼 객체를 생성해서 사용**합니다.

<br>

아까 만든 교복 클래스를 살펴보겠습니다.

```java
public class Uniform {
    String size;
    String studentName;

    void wear() {
        System.out.println(studentName + " 학생이 교복을 입었습니다. 사이즈: " + size);
    }
}
```

<br>

이 교복(Uniform) 클래스를 통해 객체를 만들어보겠습니다!

```java
// Main 함수 안에서 코드 작성

Uniform u1 = new Uniform();
u1.size = "M";
u1.studentName = "김민지";

Uniform u2 = new Uniform();
u2.size = "L";
u2.studentName = "이준호";

u1.wear();
u2.wear();
```

<br>

▫️ 실행 결과

```
김민지 학생이 교복을 입었습니다. 사이즈: M
이준호 학생이 교복을 입었습니다. 사이즈: L
```

<br>
<br>

### 👉 변수(Variable) : 객체의 상태, 속성

변수에 대해서는 예전에 배웠었죠?

객체지향적 관점에서 ‘변수’는 조금 다르게 봐야 합니다.

<br>

단순히 값을 저장하는 공간이 아니라,

‘객체의 상태’를 저장하는 역할로 봅니다.

<br>

예를 들어, 커피라는 객체가 있다면,

- 메뉴 이름
- 가격
- 온도

같은 정보는 그 **객체가 어떤 상태인지**를 나타내죠?

이걸 바로 ‘**필드(인스턴스 변수)**’라고 부릅니다.

<br>

그런데 계산할 때 잠깐 쓰는 변수들은,

객체의 상태라기보다는 일시적인 작업 도구에 가깝습니다.

그건 **지역 변수**라고 합니다!

<br>

그리고 **클래스 전체에서 공유해야 하는 정보**도 따로 있을 수 있겠죠?

그럴 땐 **static 변수**를 씁니다.

<br>

이 세 가지 변수에 대해 다뤄보겠습니다.

<br>

**1️⃣ 필드(Field) : 객체가 평생 들고 다니는 정보**

객체가 가진 고유한 정보를 저장하는 변수입니다.

클래스 안에서, **메서드 바깥에 선언**합니다.

<br>

스타벅스 커피를 하나 주문했을 때, 컵에 뭐라고 써 있죠?

- 메뉴 : 아메리카노
- 온도 : 60도
- 가격 : 4000원

이런 건 **커피 객체에 영구적으로 붙은 라벨**입니다.

→ 이런 정보들이 바로 **필드(Field)**입니다!

<br>

**🔹 예시**

```java
public class Coffee {
    String name;        // 필드
    int temperature;    // 필드
    int price;          // 필드
}
```

이 변수들을 사용할 때는 앞의 예시들처럼 객체를 생성한 후, `객체 이름.변수명` 으로 사용하면 됩니다!

<br>

**2️⃣ 지역변수(Local Variable) : 잠깐 쓰고 버리는 메모지**

지역 변수는 메서드 안에서만 잠깐 쓰고 사라지는 변수입니다.

비유하자면, 메모장에 끄적이는 계산이라고 볼 수 있습니다.

<br>

커피 가격 4000원을 보고, ‘10% 적립이니까 400원 적립!’이라고 계산을 하는 겁니다!

→ 계산 결과를 잠깐 메모장에 적고,

→ 다 끝나면 찢어서 버리죠.

이게 바로 **지역변수**예요!

<br>

**🔹 예시**

```java
void printInfo() {
    int point = price / 10;  // 지역변수
    System.out.println("적립 포인트: " + point);
}
```

`point`는 `printInfo()` 메서드가 실행되는 동안만 살아있고, 끝나면 사라집니다.

그렇기 때문에 이 메서드 밖에서는 이 변수를 부를 수도, 사용할 수도 없습니다.

이미 찢어버린 메모지인 거죠!

<br>

**3️⃣ static 변수 : 가게 전체가 공유하는 정보**

객체마다 따로 있는 게 아니라, 클래스 전체가 공유하는 변수입니다.

<br>

한 카페에서 커피 할인 행사를 진행하고 있습니다.

‘전 메뉴 10% 할인합니다!’

<br>

그러면, 아메리카노든, 라떼든, 모두 같은 할인율이 적용되겠죠?

커피 한 잔마다 다르게 할인율을 저장할 필요 없습니다.

→ 이럴 땐 **static 변수**로 딱 한 번만 저장해두면 됩니다!

<br>

**🔹 static 변수 기본 문법**

```java
static 데이터타입 변수 = 값;
```

<br>

**🔸 static 변수 예시**

```java
public class Coffee {
    static double discountRate = 0.1;  // 모든 커피가 공유하는 할인율

    String name;
    int price;

    void printDiscountedPrice() {
        int discounted = (int)(price * (1 - discountRate)); // price * 0.9를 통해 할인된 가격 계산
        System.out.println(name + "의 할인된 가격: " + discounted + "원");
    }
}
```

`discountRate`는 모든 커피 객체가 **같이 사용**하는 변수입니다.

<br>

**🔹 static 변수 사용 문법**

```java
클래스이름.변수명
```

<br>

**🔸 static 변수 사용 예시**

```java
System.out.println(Coffee.discountRate);  // 0.1 출력
```

만약 외부에서 static 변수의 값을 사용할 거라면 이렇게 사용하면 됩니다.

객체가 없어도 클래스가 갖고 있는 값이기 때문에,

객체 없이도 클래스 이름으로 바로 접근할 수 있습니다!

<br>

**✅ 변수 종류 정리**

| 구분 | 위치 | 수명 | 목적 | 접근 방법 |
| --- | --- | --- | --- | --- |
| 필드(= 인스턴스 변수) | 클래스 안, 메서드 밖 | 객체가 살아있는 동안 | 객체 고유 정보 | 객체명.필드 |
| 지역 변수 | 메서드 안 | 메서드 실행 중 | 임시 계산용 | 변수명 |
| static 변수(= 클래스 변수) | 클래스 안, static 붙음 | 프로그램 종료 시까지 | 클래스 공용 정보 | 클래스명.변수 |

<br>
<br>

### 👉 메서드(Method) : 객체의 행동, 기능 버튼

자판기를 예로 들어볼까요?

자판기에는 **버튼**이 있죠.

버튼을 누르면 커피가 나옵니다☕

이 버튼 하나하나가 바로 자바에서 말하는 **메서드(Method)**입니다.

<br>

메서드는 **객체가 할 수 있는 행동**입니다!

<br>

그럼 교복이라는 객체에는 어떤 행동이 있을까요?

- 입기
- 브랜드 라벨 보여주기
- 사이즈 확인하기

이런 것들은 **교복을 통해 할 수 있는 동작들**,

즉, 객체의 메서드가 될 수 있습니다.

<br>

‘이런 건 사람이 하는 거 아닌가요?’라는 질문이 떠오르죠?

<br>

맞습니다!

현실에서는 당연히 사람이 합니다.

하지만 **프로그래밍 세계에서는 다릅니다.**

<br>

객체는 단순히 정보를 담고 있는 덩어리가 아니라,

정보(데이터)와 그걸 다루는 기능(행동)을 함께 갖는 단위입니다.

<br>

즉, 객체는

**‘자신이 가진 정보를, 자신이 직접 설명하거나 조작할 수 있는 존재’**인 거예요.

<br>

예를 들어, 어떤 교복 객체에게 이렇게 요청할 수 있습니다!

- 브랜드 알려줘! → `showLabel()`
- 사이즈 괜찮은지 확인해줘! → `checkSize()`

이걸 자바에서는 ‘**메서드를 호출한다’고 표현합니다.**

<br>

현실의 교복은 말하지 않지만,

프로그래밍에서는 **교복 객체에게 요청하면,**

**그 객체가 스스로 응답해주는 방식**으로 동작하는 것입니다.

<br>

그래서 메서드는,

객체 안에 있는 ‘사용 설명서 버튼’ 같은 존재라고 볼 수 있습니다.

<br>

외부에서 그 버튼을 누르면

→ 객체는 자기가 가진 정보를 바탕으로

→ **결과를 보여주거나, 어떤 행동을 해주는 것처럼 반응**합니다.

<br>

**🔹 메서드 기본 문법**

```java
반환타입 메서드이름(자료형 매개변수1, 자료형 매개변수2...) {
    // 1. 매개변수를 받아서
    // 2. 계산하거나 처리하고
    // 3. 결과값을 return으로 돌려줍니다.
}
```

- 매개변수 = 파라미터 : 메서드가 실행될 때 받는 값들
    - 이 메서드를 실행하기 위해서 메서드를 호출할 때 받아야 하는 값입니다.
    - `데이터타입 매개변수이름`으로 작성합니다.
    - 매개변수가 필요 없다면 괄호 안을 비워두고, 그냥 ()만 작성하면 됩니다.
- 반환타입 : 결과를 돌려줄지 여부
    - 반환할 결과가 없다면 반환타입 대신 `void`를 작성합니다.
    - 만약 반환 타입이 있다면, `return 반환값`으로 반환을 해야 합니다.
    - `return`을 쓰면 메서드의 결과를 변수에 저장하거나, 다른 계산에 활용할 수 있습니다.
    - 메서드의 반환 타입과 return 값의 타입이 반드시 일치해야 합니다.

<br>

**🔸 메서드 작성 예시 : 교복 클래스**

```java
public class Uniform {
    String size;
    String brand;
    int price;
    static String schoolName = "커피고등학교";

		// 반환 타입이 없는 메서드
    void wear() {
        System.out.println(schoolName + " 교복을 입었습니다. 사이즈: " + size);
    }

    void showLabel() {
        System.out.println("브랜드: " + brand);
    }

    void checkSize() {
        if (size.equals("L")) {
            System.out.println("이 교복은 넉넉한 사이즈예요!");
        } else {
            System.out.println("보통 또는 작은 사이즈입니다.");
        }
    }

    // 반환 타입이 있는 메서드
    int getDiscountedPrice(int discountRate) {
        int discounted = price - (price * discountRate / 100);
        return discounted;
    }
}
```

<br>

**🔸 메서드 사용 예시 : 교복 클래스**

```java
public class Main {
    public static void main(String[] args) {
        Uniform u1 = new Uniform();
        u1.size = "L";
        u1.brand = "포근포근";
        u1.price = 100000;

        u1.wear();
        u1.showLabel();
        u1.checkSize();

        int finalPrice = u1.getDiscountedPrice(20);
        System.out.println("할인된 가격: " + finalPrice + "원");
    }
}
```

`객체.메서드()`를 **메서드 호출**이라고 합니다.

<br>

**▫️ 실행 결과**

```
커피고등학교 교복을 입었습니다. 사이즈: L
브랜드: 포근포근
이 교복은 넉넉한 사이즈예요!
할인된 가격: 80000원
```

여기서 잠깐!

지금까지 만든 `wear()`, `showLabel()` 같은 메서드들은

교복 객체를 만든 후에야 사용할 수 있는 인스턴스 메서드였습니다.

<br>

하지만 어떤 기능은

**특정 교복 한 벌이 아니라, 교복 전체가 공통으로 제공하는 기능**일 수도 있어요.

<br>

예를 들어 이런 상황을 떠올려볼까요?

- 교복 가격 정책은 어떻게 되나요?
- 교복에 적용되는 할인율은 몇 %인가요?

이런 건 **교복 한 벌이 아닌, 교복 자체에서 알려줘야 할 정보**입니다.

<br>

바로 이런 기능을 할 때 사용하는 게 **static 메서드**입니다!

static 변수와 같은 개념의 메서드라고 생각하시면 편합니다.

<br>

**🔹 static 메서드 기본 문법**

```java
static 반환타입 메서드이름(매개변수) {
    // 실행할 코드
}
```

- **static** 키워드가 붙으면 `클래스명.메서드명()`으로 바로 호출 가능합니다.
- 객체를 만들 필요가 없습니다!

<br>

**🔸 static 메서드 사용 예시**

```java
public class Uniform {
    String size;
    String brand;
    int price;
    static String schoolName = "커피고등학교";

    void wear() { ... }
    void showLabel() { ... }
    void checkSize() { ... }
    int getDiscountedPrice(int discountRate) { ... }

    // static 메서드
    static void showSchoolPolicy() {
        System.out.println("모든 교복은 첫 구매 시 10% 할인이 적용됩니다.");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        // static 메서드는 객체 없이 바로 호출 가능!
        Uniform.showSchoolPolicy();
    }
}

```

<br>

**▫️ 실행 결과**

```java
모든 교복은 첫 구매 시 10% 할인이 적용됩니다.
```
