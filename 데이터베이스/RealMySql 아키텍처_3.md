### 버퍼 풀과 리두 로그

InnoDB의 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정하면 할수록 쿼리의 성능이 빨라진다.

**InnoDB 버퍼 풀의 성능향상 용도**

- 데이터 캐시
- 쓰기 버퍼링

버퍼 풀의 메모리 공간만 단순히 늘리는 것은 데이터 캐시 기능만 향상시키기 때문에 버퍼링 기능까지 올리기 위해선 InnoDB 버퍼 풀과 리두 로그와의 관계를 먼저 이해해야 함

### 버퍼 풀과 리두 로그와의 관계

더티 페이지는 값이 변경되어있는 페이지이기 때문에 디스크와 메모리(버퍼 풀)의 데이터 상태가 다르고, 버퍼풀에 무한정 머무를 수는 없기 때문에, 언젠가는 디스크로 기록해야 한다.

→ 버퍼 풀에 리두 로그가 1:1로 매칭 되어있기 때문에. 이때 매칭 되어있는 버퍼 풀 공간은 재사용이 불가능한 공간인데, 이를 `활성 리두 로그(Active Redo Log)`라고 한다.

→ 리두 로그 파일의 공간이 매번 순환되며 기록될 때마다 `LSN(Log Sequence Number)`이라는 증가되는 값을 갖게된다. 체크포인트 이벤트가 발생되어 더티 페이지를 디스크로 동기화할 때 가장 최근 체크포인트 지점은 최근LSN의 활성 리두 로그 공간이 된다.

⇒ 더티 페이지는 특정 리두 로그 엔트리와 관계를 갖고, 체크포인트가 발생하면 체크 포인트 LSN보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화돼야 한다.

ex)

- InnoDB 버퍼 풀은 100GB이고, 리두 로그 파일의 전체 크기는 100MB일 때
    - 체크 포인트 에이지 : 100MB
    - 평균 리두 로그 엔트리가 4KB라면 25600(100MB/4KB)의 더티 페이지만 버퍼 풀에 보관이 가능하기 때문에 버퍼링을 위한 효과를 거의 보지 못한다.
    - `잘못된 설정`
- InnoDB 버퍼 풀은 100MB이고, 리두 로그 파일의 전체 크기는 100GB일 때
    - 더티 페이지 : 100MB
    - 더티 페이지가 100MB밖에 안되기 때문에 급작스러운 디스크 쓰기가 발생할 가능성이 높다.

### 버퍼 풀 플러시(Buffer Pool Flush)

디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 다음과 같이 2개의 플러시 기능을 백그라운드로 실행한다.

- 플러시 리스트(Flush_list)플러시
- LRU 리스트(LRU_list) 플러시

### 플러시 리스트 플러시

리두 로그 엔트리가 사용하는 공간을 비울 때, 공간이 지워지려면 반드시 InnoDB 버퍼 풀의 더티 페이지가 먼저 디스크로 동기화돼야 한다. 이를 위해 `플러시 리스트 플러시 함수를 호출`해서 `오래된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행한다.`

이 때 사용되는 InnoDB 스토리지 엔진 시스템 변수는 다음과 같다.

- innodb_page_cleaners
    - 더티 페이지를 디스크로 동기화하는 스레드인 클리너 스레드(Cleaner Thread)의 개수를 조정
    - 가능하면 innodb_buffer_pool_instances 설정값과 동일한 값으로 설정
- innodb_max_dirty_pages_pct
    - 전체 버퍼 풀이 가진 페이지의 `90%`까지 더티 페이지를 가질 수 있는데, 이 변수를 이용해 비율을 조정할 수 있다.
- innodb_max_dirty_pages_pct_lwm
    - 버퍼 풀에 더티 페이지가 많을 수록 디스크 쓰기 폭발(Disk IO Burst)현상이 발생할 가능성이 있는데, 이 변수로 더티 페이지의 개수를 설정할 수 있다.
    - 일정 수준 이상의 더티 페이지가 발생하면 조금씩 더티 페이지를 디스크로 기록하게 한다.
    `기본 값 10%`
- innodb_io_capacty
    - 일반적인 상황에서 디스크가 적절히 처리할 수 있는 수준의 값
- innodb_io_capacity_max
    - 디스크가 최대의 성능을 발휘할 때 어느 정도의 백그라운드 스레드가 디스크를 작업하는지 설정, 버퍼 풀의 더티 페이지 쓰기 + 쿼리문 처리를 위한 디스크 읽기
- innodb_adaptive_flushing
    - capacity와 capacity_max의 설정 값에 의존하지 않고, 새로운 알고리즘을 사용 `기본값 ON`
- innodb_adaptive_flushing_lwm
    - 전체 리두 로그 공간에서 활성 리두 로그 공간이 `기본 값10%`를 넘어서면 작동
- innodb_flush_neighbors
    - 더티 페이지를 디스크에 기록할 때 디스크에서 근접한 페이지 중 더티 페이지가 있다면 함께 묶어서 기록하게하는 기능 - `SSD를 사용하면 비활성 HDD를 사용하면 활성`

### LRU 리스트 플러시

LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들어야 하는데, 이 때 LRU 리스트 플러시 함수가 사용된다.

`innodb_lru_scan_depth` 시스템 변수에 설정된 개수만큼 페이지를 스캔하며, 더티 페이지는 디스크에 동기화하게 하고, 클린 페이지는 프리 리스트로 페이지를 옮긴다.

LRU리스트의 스캔은 `(innodb_buffer_pool_instances * innodb_lru_scan_depth)` 수만큼 수행됨

### 버퍼 풀 상태 백업 및 복구

InnoDB 서버의 버퍼 풀은 쿼리의 성능에 매우 밀접하게 연결돼 있다. 디스크의 데이터가 버퍼 풀에 적재돼 있는 상태를 워밍업(Warming Up)라고 표현하는데, 5.6 버전부터는 버퍼 풀 덤프 및 적재 기능이 도입되어 `innodb_buffer_pool_dump_now` 시스템 변수를 이용해 현재 InnoDB 버퍼 풀의 상태를 백업할 수 있고, `innodb_buffer_pool_load_now` 시스템 변수를 이용해 백업된 버퍼 풀의 상태를 다시 복구할 수 있다.

InnoDB 자체적으로 버퍼 풀의 백업과 복구설정이 가능 → `innodb_buffer_pool_dump_at_shutdown + innodb_buffer_pool_load_at_startup` 설정

### 버퍼 풀의 적재 내용 확인

MySQL 5.6버전부터 버퍼 풀의 메모리에 어떤 테이블의 페이지가 적재되어 있는지 확인할 수 있었는데, 실 서비스 중에는 많은 부하를 일으켜 사용하지 못했었다. 이후 MySQL 8.0 버전에서는 버퍼 풀의 어떤 테이블의 페이지들이 적재되어있는지 테이블의 인덱스별로 데이터 페이지가 얼마나 적재되어 있는지 확인이 가능해졌다.

`information_schema (DATABASE) → innodb_cached_indexes (TABLE)`

## Double Write Buffer

InnoDB 스토리지 엔진의 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록한다. 더티 페이지를 디스크 파일로 플러시할 때 문제가 생겨 일부만 기록된다면(Partial-page, Torn-page) 복구가 불가능했을 텐데 이를 막기 위해 `Double-Write` 기법을 이용한다.

InnoDB에서 A → E 까지의 더티 페이지를 디스크로 플러시한다고 가정했을 때 실제 데이터 파일에 변경 내용을 기록하기 전에 A → E 까지의 더티 페이지를 묶어서 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록한다. 이후 변경 내용이 정상적으로 기록된다면 사라진다.

DoubleWrite활성 시스템 변수는 `innodb_doublewrite` 이다.

| HDD | SSD | SSD(무결성중요) |
| --- | --- | --- |
| 부담X | 비용 비쌈 | 고려 |

## 언두 로그

트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업한다. 이를 (Undo log)라고 한다.

언두 로그의 특징

- 트랜잭션 보장
    - 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해 둔 이전 버전의 데이터를 이용해 복구한다.
- 격리 수준 보장
    - 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환한다.
