# InnoDB 스토리지 엔진 아키텍처

InnoDB 엔진의 특징

- 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공한다.
- 위의 이유로 동시성 처리가 가능하고 안정적이며, 성능이 뛰어나다.

InnoDB의 각 특성을 확인해 볼 것이다.

## 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블을 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다.
- 프라이머리 키값을 논리적인 주소로 사용하며, 해당 값을 인덱스화 한다.
- 프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔이 빨리 처리될 수 있다.
- InnoDB는 클러스터링 키를 지원하지만, MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않는다.
    
    → MyISAM 에서 프라이머리 키는 그저 유니크 제약을 가진 세컨더리 인덱스
    

## 외래 키 지원

외래 키에 대한 지원은`InnoDB 스토리지 엔진 레벨에서 지원`하는 기능으로 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.

혹시 외래키로 인해 문제가 생겼다면 일시적으로 해제할 수 있다.

```java
mysql> SET foreign_key_checks=off;
mysql> SET SESSION foreign_key_checks=off;
시스템 변수의 적용범위가 GLOBAL, SESSION 둘 다 있지만, 일반적으로 SESSION에서만 사용하기 때문에
두 명령은 동일하게 SESSION범위에 적용이된다.
```

외래키 체크를 해제한 후에 작업을 했다면, CASCADE관련 옵션이 무시되니 유의해야 한다.

## MVCC(Multi Version Concurrency Control)

레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능, InnoDB는 언두 로그(Undo log)를 이용해 이 기능을 구현한다.

`MVCC의 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는 것`

기존의 데이터 값을 UPDATE 처리했을 때 데이터베이스에는 Undo log, InnoDB버퍼 풀을 통해 값을 갖고있다. 이 트랜잭션이 진행 중에 읽기 요청이 들어왔을 때 격리 수준(Isolation leve)에 따라 버퍼 풀이나 언두 로그에 있는 데이터중 하나를 뱉게 된다. 이후 작업을 마친 후 COMMIT을 마칠 때까지도 살아있으며, 사라지는 타이밍은 언두 영역을 필요로 하는 트랜잭션이 더는 없을 때 삭제된다.

```java
💡트랜잭션 격리 수준
- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE
```

## 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- MVCC기술을 통해 잠금을 걸지 않고 읽기 작업을 수행한다.
- 잠금을 걸지 않기 때문에 트랜잭션이 걸려도 잠겨져 있지 않고 격리수준에 따라 데이터를 반환한다.
- 때문에 순수 읽기 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.
- 이 때 트랜잭션은 다른 사용자의 SELECT의 작업을 방해하지 않는데 이를 `잠금 없는 일관된 읽기` 라고 표현한다.
- 혹시나 오랜 시간 활성상태인 트랜잭션으로 인해 MySQL이 느려진다면 언두 로그가 일관된 읽기를 위해 남아있는 경우 발생하는 문제이기 때문에 트랜잭션은 가능한 짧게 잡는 것이 좋다.

## 자동 데드락 감지

InnoDB 스토리지 엔진은 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기목록을 그래프 형태로 관리한다.

데드락을 감지했을 때 시스템이 교착상태를 검사해 교착 상태에 빠진 트랜잭션을 찾아서 그중 하나를 강제 종료하는데, 교착에 빠진 것중 우선순위는 언두 로그 레코드를 가장 적게 가진 트랜잭션이 일반적으로 롤백의 대상이 된다. 

→ 롤백을 해도 언두 처리를 해야 할 내용이 적다는 것이기 때문

```java
관련 환경 변수
innodb_table_locks
-> 스토리지 엔진 내부의 레코드 잠금, 테이블 레벨의 잠금 수준까지 데드락 감지 가능

innodb_deatlock_detect
-> 데드락 감지 on/off

innodb_lock_wait_timeout
-> 제한 시간동안 트랜잭션 응답이 완료되지 않으면 요청을 실패 처리 ->기본값 50초
```

## 자동화된 장애 복구

InnoDB에서는 손실이나 장애로부터 데이터를 보호하기 위한 여러 메커니즘을 활용한다. MySQL 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행된다.

InnoDB스토리지 엔진 자체의 문제로 데이터 파일이 손상되거나 MySQL 서버가 시작되지 못하는 경우는 거의 발생하지 않지만, 서버와 무관하게 디스크나 서버 하드웨어 이슈로 InnoDB 스토리지 엔진이 복구를 못 하는 경우도 발생할 수 있다. 이때 선택할 수 있는 방법은 두 가지로 나뉜다.

- `innodb_force_recovery` 시스템 변수 설정으로 데이터 파일이나 로그 파일의 손상 여부 검사 과정 진행
설정 값은 1~6으로 값이 커질수록 그만큼 심각한 상황
    - **1**(SRV_FORCE_IGNORE_CORRUPT)
        - InnoDB의 테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견돼도 무시하고 서버를 시작
        - `Database page corruption on disk or a failed` 메시지가 출력되는 경우 대부분 이 경우
    - **2**(SRV_FORCE_NO_BACKGROUND)
        - InnoDB의 메인 스레드가 언두 데이터를 삭제하는 과정에서 장애가 발생하면 이 모드로 복구
    - **3**(SRV_FORCE_NO_TRX_UNDO)
        - 서버를 다시 시작할 때 트랜잭션이 걸려있는 것들을 어떻게 할지 선택하는 모드
        - 트랜잭션 도중 서버가 꺼져있다면 롤백되는 것이 맞지만, 해당 설정을 킨다면 `트랜잭션 상태가 그대로 유지됨`
    - **4**(SRV_FORCE_NO_IBUF_MERGE)
        - 데이터 변경으로 인한 인덱스 변경 작업이 버퍼에 들어가 있는 상태로 MySQL을 재시작했을 때 인서트 버퍼의 손상을 감지하면 에러가 발생된다.
        - `인서트 버퍼 손상에러발생을 무시하는 옵션`
    - **5**(SRV_FORCE_NO_UNDO_SCAN)
        - 서버 재시작 도중 언두 로그를 사용할 수 없을 때 발생하는 오류
        - 옵션을 설정하면 언두 로그를 모두 무시하고 시작
        - mysqldump를 이용해 데이터를 백업하고, 새로 구축해야 함
    - **6**(SRV_FORCE_NO_OG_REDO)
        - 리두 로그가 손상되었을 때 발생하는 에러를 무시하는 옵션
        - mysqldump를 이용해 데이터를 백업하고 새로 구축
- 위의 방법도 실패했을 때 백업을 이용해 다시 구축

## InnoDB 버퍼 풀

- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할

### 버퍼 풀의 크기 설정

InnoDB의 버퍼 풀은 5.7버전부터 동적으로 조절할 수 있게 됐기 때문에 적절히 작은 값을 설정 후 상황을 보고 점진적으로 증가 시키는 방법이 가장 좋다.

50% 설정 이후 상황에 맞게 천천히 올리기.

!버퍼 풀 크기 변경은 크리티컬하기 때문에 서버가 한가한 시점에 변경해야 한다. 또, 크기를 줄이는 작업은 서비스 영향도가 매우 크므로 가능하면 풀의 크기를 줄이는 작업은 하지 않도록 주의해야 한다.

버퍼 풀의 내부적 청크 단위 : 128MB

### 버퍼 풀의 구조

**LRU(Least Recently Used) 리스트**, **플러시(Flush) 리스트**, **프리 리스트** 라는 3개의 자료구조를 관리

- LRU 리스트를 엄밀하게 따지면
    - Old 서브리스트 영역 : LRU
    - New 서브리스트 영역 : MRU
    - **InnoDB 스토리지 엔진에서 데이터를 찾는 과정**
        
        ```java
        1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
        	A. InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
        	B. 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지를 검색
        	C. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급
        2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고,
        		적재된 페이지에 대한 포인터를 LRU 헤더에 추가
        3. 버퍼 풀의 LRU 헤더에 적재된 데이터 페이지가 읽히면 MRU 헤더 부분으로 이동
        4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했는지에 따라
        		나이가 부여되며 상주하다 오래되었을 때 제거된다.
        5. 필요한 데이터가 자주 접근됐다면 해당 페이지 인덱스 키를 어댑티브 해시 인덱스에 추가
        ```
        
- 플러시 리스트는 디스크로 동기화 되지 않은 데이터를 가진 데이터 페이지의 변경 시점 기준의 페이지 목록을 관리
- 데이터의 변경이 가해진 데이터 페이지는 플러시 리스트가 관리, 변경 내용을 리두 로그에 기록, 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다.
