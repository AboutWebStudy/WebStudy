# MySQL 엔진 아키텍처

MySQL의 서버는 다른 DBMS에 비해 구조가 독특하다.

## MySQL의 전체 구조

![image](https://github.com/user-attachments/assets/b5982b81-ec59-419c-a68d-d07c3db7f06c)

MySQL 서버는 크게 MySQL엔진과 스토리지 엔진으로 구분할 수 있다.

### MySQL엔진

MySQL엔진은 클라이언트 접속을 처리하기 위한 `커넥션 핸들러`, `SQL파서`, `전처리기`, 쿼리의 최적화된 실행을 위한 `옵티마이저`가 중심을 이룬다. 또한 MySQL은 표준 SQL(ANSI SQL)문법을 지원하기 때문에`(SQL 인터페이스)` 타 DBMS와 호환되어 실행될 수 있다.

### 스토리지 엔진

MySQL 엔진이 요청된 SQL문장을 분석하거나 최적화한 이후 처리된 분석문이나 데이터를 디스크 스토리지를 통해 읽어오거나 저장하는 등의 실제 작업이 이루어진다.

MySQL엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용할 수 있는데, 예제와 같이 선언할 수 있다.

```java
mysql> CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```

test_table은 InnoDB 스토리지 엔진을 사용하도록 정의되었다.

INSERT, UPDATE, DELETE, SELECT, … 등 작업이 발생했을 때 InnoDB 스토리지 엔진이 처리를 담당한다.

### 핸들러 API

MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야할 때 각 스토리지 엔진에 쓰기 또는 읽기를 요청한다. 이 요청을 `핸들러(Handler)` 요청이라 하고, 여기서 사용되는 API를 핸들러 API라고 한다.

```java
핸들러 요청 확인 명령어
mysql> SHOW GLOBAL STATUS LIKE 'Handler%';
```

## MySQL 스레딩 구조

- MySQL서버는 스레드 기반
- 포그라운드(Foreground)스레드, 백그라운드(Background)스레드로 구분할 수 있다.
- 많은 스레드 중 `thread/sql/one_connection` 스레드만 실제 사용자의 요청을 처리하는 포그라운드 스레드다.
- 동일한 이름을 갖고 있는 스레드가 있다면 여러 스레드가 하나의 작업을 병렬로 처리하는 경우다.

```java
mysql> SELECT thread_id, name, type, processlist_user, processlist_host 
FROM performance_schema.threads ORDER BY type, thread_id;
```

![image](https://github.com/user-attachments/assets/550025d0-b084-4b5f-b504-d7612ae17e48)


processlist_host에 localhost가 두개가 잡혀있음

### 포그라운드 스레드(클라이언트 스레드, 사용자 스레드)

주로 클라이언트 사용자가 요청하는 쿼리문을 처리한다. 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 다시 스레드 캐시(Thread cache)로 되돌아간다.

이미 스레드 캐시에 일정 개수 대기중인 스레드가 있다면 스레드를 즉시 종료시켜 일정 개수만 존재하게 한다. 이 때 설정되는 개수 관련한 시스템 변수는 `thread_cache_size`이다.

포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없다면 직접 디스크의 데이터나 인덱스 파일을 통해서 데이터를 가져와 처리한다.

MyISAM 테이블 → `디스크 쓰기 작업까지`

InnoDB 테이블 → `데이터 버퍼나 캐시까지` 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.

### 백그라운드 스레드

**InnoDB의 백그라운드 처리 스레드 종류**

- 인서트 버퍼(Insert Buffer)를 병합하는 스레드
- `로그를 디스크로 기록하는 스레드`
- InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
- `데이터를 버퍼로 읽어 오는 스레드`
- 잠금이나 데드락을 모니터링하는 스레드

MySQL 5.5버전부터 데이터 쓰기 쓰레드와 데이터 읽기 쓰레드의 개수를 2개 이상 지정이 가능해졌고, `innodb_write_io_threads`와 `innodb_read_io_threads` 시스템 변수로 스레드의 개수를 설정한다.

사용자의 요청을 처리하는 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만, 데이터의 읽기 작업은 절대 지연될 수 없다.

**두 스토리지 엔진 비교**

- **InnoDB**
    - 포그라운드 스레드 → 읽기 처리
    - 백그라운드 스레드 → 쓰기 작업을 버퍼링 해서 일괄 처리한다.
    - INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다.
- **MyISAM**
    - 포그라운드 스레드에서 전체 처리
    - 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계돼 있다.
    - 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.

## 메모리 할당 및 사용 구조

MySQL 사용 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다. 글로벌 메모리 영역은 모든 메모리 공간은 MySQL서버가 시작되면서 운영체제로부터 할당된다.

- **글로벌 메모리 영역**
    - 일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당
        - 테이블 캐시
        - InnoDB 버퍼 풀
        - InnoDB 어댑티브 해시 인덱스
        - InnoDB 리두 로그 버퍼
- **로컬 메모리 영역(세션 메모리 영역)**
    - 로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되지 않는다.
        - 정렬 버퍼(Sort Buffer)
        - 조인 버퍼
        - 바이너리 로그 캐시
        - 네트워크 버퍼

## 플러그인 스토리지 엔진 모델

MySQL의 독특한 구조중 대표적인 것이 플러그인 모델이다. InnoDB 스토리지 엔진, 전문 검색 엔진을 위한 검색어 파서를 플러그인 형태로 개발해서 사용할 수 있으며, 사용자의 인증을 위한 Native Authentication, Caching SHA-2 Authentication등 모두 플러그인으로 구현되어 제공된다.

MySQL에서 쿼리가 실행되는 과정 중 스토리지 엔진은 데이터를 읽기/쓰기를 할 때만 사용되는 엔진이다.

**MySQL 쿼리문 간략 실행과정**

SQL 파서 → SQL 옵티마이저 → SQL 실행기 → `데이터 읽기/쓰기` → 디스크

그중 스토리지 엔진은 MySQL 엔진이 스토리지 엔진을 조종할 때 핸들러를 통해 사용한다. 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/063bb2d1-ee4b-4cdf-a8cb-3612352a6b48/54eb85a9-2dae-4efa-9766-d73ff867f3d0/Untitled.png)

Support 칼럼에 표시될 수 있는 값

- YES : MySQL 서버(mysqld)에 해당 스토리지 엔진이 포함돼 있고, 사용 가능으로 활성화된 상태
- DEFAULT : ‘YES’와 동일한 상태이지만 필수 스토리지 엔진임을 의미함
- NO : 현재 MySQL 서버(mysqld)에 포함되지 않았음을 의미함
- DISABLED : 현재 MySQL 서버(mysqld)에는 포함됐지만 파라미터에 의해 비활성화된 상태

`SHOW PLUGINS;`를 통해 다양한 플러그인도 확인할 수 있다.

## 컴포넌트

MySQL 8.0부터 기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원된다.

- 플러그인은 MySQL서버와 인터페이스 가능하고, 플러그인끼리는 통신할 수 없다.
- MySQL서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화x)
- 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

예시) 비밀번호 검증 기능 : 기존 5.7ver 까지는 플러그인 형태 → 8.0 컴포넌트

```java
-- // validate_password 컴포넌트 설치
mysql> INSTALL COMPONENT 'file://component_validate_password';

-- // 설치된 컴포넌트 확인
mysql> SELECT * FROM mysql.component;
```

## 쿼리 실행 구조

- MySQL 엔진
    - 쿼리 파서 : 쿼리 문장을 토큰 단위로 분리해 트리 형태의 구조로 만들어진다.
    - 전처리기 : 파서 과정에서 만들어진 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.
        - 문제 확인 요소 : 테이블 이름, 칼럼 이름, 내장 함수 등 매핑을 권한이나 존재를 확인
    - 옵티마이저 : 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정 `DBMS의 두뇌이자 핵심`
    - 실행 엔진 : 옵티마이저에서 준비한 명령들을 실질적으로 핸들러에게 전달하는 엔진
- 핸들러 (스토리지 엔진)
    - 데이터를 디스크에 저장하거나 읽어오는 역할

## 스레드 풀

스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원소모를 줄이는 목적의 풀이다.

커뮤니티 버전에서 사용할 수 있는 스레드풀은 Percona Server의 스레드풀이다.

- 컨텍스트 스위치를 줄여서 오버헤드를 낮출 수 있다.
- 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공한다.

## 트랜잭션 지원 메타데이터

테이블의 구조 정보와 스토어드 프로그램 등의 정보를 데이터 딕셔너리 또는 메타데이터라고 하는데, MySQL 5.7ver 까지는 파일기반의 메타데이터를 저장하고 있었기에 테이블의 생성 또는 변경 도중에 MySQL 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남는 문제가 있었다. 이를 해결하기 위해 8.0버전 부터는 테이블 메타데이터를 InnoDB의 테이블에 저장하도록 개선되었다.

- MySQL 서버의 테이블 구조를 변경할 때는 기존의 FRM 파일에 저장하여 변경작업을 진행했는데, 파일 기반의 변경작업은 트랜잭션을 지원하지 않았기 때문에 변경 도중 문제가 생겨 비정상종료가 되었다면, 일부만 변경된 애매한 상태로 테이블이 깨지게 되었다.

---

# InnoDB 스토리지 엔진 아키텍처

InnoDB 엔진의 특징

- 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공한다.
- 위의 이유로 동시성 처리가 가능하고 안정적이며, 성능이 뛰어나다.

InnoDB의 각 특성을 확인해 볼 것이다.

## 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블을 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다.
